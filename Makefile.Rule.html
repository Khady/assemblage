<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html>
<head>
<link rel="stylesheet" href="style.css" type="text/css">
<meta content="text/html; charset=iso-8859-1" http-equiv="Content-Type">
<link rel="Start" href="index.html">
<link rel="next" href="Makefile.Variable.html">
<link rel="Up" href="Makefile.html">
<link title="Index of types" rel=Appendix href="index_types.html">
<link title="Index of values" rel=Appendix href="index_values.html">
<link title="Index of modules" rel=Appendix href="index_modules.html">
<link title="Index of module types" rel=Appendix href="index_module_types.html">
<link title="Flags" rel="Chapter" href="Flags.html">
<link title="Shell" rel="Chapter" href="Shell.html">
<link title="Feature" rel="Chapter" href="Feature.html">
<link title="Resolver" rel="Chapter" href="Resolver.html">
<link title="Git" rel="Chapter" href="Git.html">
<link title="Action" rel="Chapter" href="Action.html">
<link title="Build_env" rel="Chapter" href="Build_env.html">
<link title="Project" rel="Chapter" href="Project.html">
<link title="Ocamlfind" rel="Chapter" href="Ocamlfind.html">
<link title="Makefile" rel="Chapter" href="Makefile.html">
<link title="OCaml" rel="Chapter" href="OCaml.html">
<link title="Opam" rel="Chapter" href="Opam.html">
<link title="Assemblage" rel="Chapter" href="Assemblage.html"><title>Makefile.Rule</title>
</head>
<body>
<div class="navbar">&nbsp;<a class="up" href="Makefile.html" title="Makefile">Up</a>
&nbsp;<a class="post" href="Makefile.Variable.html" title="Makefile.Variable">Next</a>
</div>
<h1>Module <a href="type_Makefile.Rule.html">Makefile.Rule</a></h1>

<pre><span class="keyword">module</span> Rule: <code class="code"><span class="keyword">sig</span></code> <a href="Makefile.Rule.html">..</a> <code class="code"><span class="keyword">end</span></code></pre><hr width="100%">
<br>
Rules.<br>

<pre><span id="TYPEt"><span class="keyword">type</span> <code class="type"></code>t</span> </pre>
<div class="info ">
A rule value.<br>
</div>


<pre><span id="VALcreate"><span class="keyword">val</span> create</span> : <code class="type">?ext:bool -><br>       targets:string list -><br>       prereqs:string list -><br>       ?order_only_prereqs:string list -> string list -> <a href="Makefile.Rule.html#TYPEt">t</a></code></pre><div class="info ">
Generate a Makefile rule:
<p>

      targets : prereqs | prereqs-only-inputs
         recipe
         ...
<p>

      If <code class="code">ext</code> is set, the rule is extensible (ie. it uses <code class="code">::</code>
      instead of <code class="code">:</code>.<br>
</div>

<pre><span id="VALtarget"><span class="keyword">val</span> target</span> : <code class="type">string</code></pre><div class="info ">
The file name of the target of the rule. If the target is an
      archive member, then <code class="code">$@</code>is the name of the archive file. In a
      pattern rule that has multiple targets (see Introduction to Pattern
      Rules), <code class="code">$@</code> is the name of whichever target caused the rule's
      recipe to be run.<br>
</div>

<pre><span id="VALtarget_member"><span class="keyword">val</span> target_member</span> : <code class="type">string</code></pre><div class="info ">
The target member name, when the target is an archive
      member. See Archives. For example, if the target is foo.a(bar.o)
      then <code class="code">$%</code> is bar.o and <code class="code">$@</code> is foo.a. <code class="code">$%</code> is empty when the
      target is not an archive member.<br>
</div>

<pre><span id="VALprereq"><span class="keyword">val</span> prereq</span> : <code class="type">string</code></pre><div class="info ">
The name of the first prerequisite. If the target got its recipe
      from an implicit rule, this will be the first prerequisite added
      by the implicit rule (see Implicit Rules).<br>
</div>

<pre><span id="VALprereqs"><span class="keyword">val</span> prereqs</span> : <code class="type">string</code></pre><div class="info ">
The names of all the prerequisites that are newer than the
      target, with spaces between them. For prerequisites which are
      archive members, only the named member is used (see
      Archives).<br>
</div>

<pre><span id="VALchanged_prereqs"><span class="keyword">val</span> changed_prereqs</span> : <code class="type">string</code></pre><div class="info ">
The names of all the prerequisites, with spaces between
      them. For prerequisites which are archive members, only the
      named member is used (see Archives). A target has only one
      prerequisite on each other file it depends on, no matter how
      many times each file is listed as a prerequisite. So if you list
      a prerequisite more than once for a target, the value of <code class="code">$^</code>
      contains just one copy of the name. This list does not contain
      any of the order-only prerequisites; for those see the <code class="code">$|</code>
      variable, below.<br>
</div>

<pre><span id="VALdedup_prereqs"><span class="keyword">val</span> dedup_prereqs</span> : <code class="type">string</code></pre><div class="info ">
This is like <code class="code">$^</code>, but prerequisites listed more than once are
      duplicated in the order they were listed in the makefile. This
      is primarily useful for use in linking commands where it is
      meaningful to repeat library file names in a particular
      order.<br>
</div>

<pre><span id="VALstem"><span class="keyword">val</span> stem</span> : <code class="type">string</code></pre><div class="info ">
The stem with which an implicit rule matches (see How Patterns
      Match). If the target is <code class="code">dir/a.foo.b</code> and the target pattern is
      <code class="code">a.%.b</code> then the stem is <code class="code">dir/foo</code>. The stem is useful for
      constructing names of related files. In a static pattern rule,
      the stem is part of the file name that matched the <code class="code">%</code> in the
      target pattern.
<p>

      In an explicit rule, there is no stem; so <code class="code">$*</code> cannot be
      determined in that way. Instead, if the target name ends with a
      recognized suffix (see Old-Fashioned Suffix Rules), <code class="code">$*</code> is set
      to the target name minus the suffix. For example, if the target
      name is <code class="code">foo.c</code>, then <code class="code">$*</code> is set to <code class="code">foo</code>, since <code class="code">.c</code> is a
      suffix. GNU make does this bizarre thing only for compatibility
      with other implementations of make. You should generally avoid
      using <code class="code">$*</code> except in implicit rules or static pattern rules.
<p>

      If the target name in an explicit rule does not end with a
      recognized suffix, <code class="code">$*</code> is set to the empty string for that
      rule.<br>
</div>
</body></html>
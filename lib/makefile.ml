(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Printf

module Variable = struct

  type assign = string

  type t = {
    name    : string;
    assign  : assign;
    contents: string;
  }

  let (=) name contents =
    { name; contents; assign = "=" }

  let (:=) name contents =
    { name; contents; assign = ":=" }

  let (+=) name contents =
    { name; contents; assign = "+=" }

  let subst t name ~input ~output =
    { name; assign = "=";
      contents = sprintf "$(${%s}:%s=%s)" t.name input output
    }

  let name t =
    sprintf "$(%s)" t.name

  let generate buf t =
    bprintf buf "%s %s %s\n" t.name t.assign t.contents

  let shell name command =
    { name; assign = "=";
      contents = sprintf "$(shell %s)" command
    }

  let files name ~dir ~ext =
    { name; assign = "=";
      contents = sprintf "$(wildcard %s/*.%s)" dir ext }

end

module Rule = struct

  type t = {
    name: string;
    targets: string list;
    prerequisites:string list;
    order_only_prerequisites:string list;
    recipe:string list;
  }

  let create ~name ~targets ~prereqs ?(order_only_prereqs=[]) ~recipe =
    { name; targets; prerequisites=prereqs; order_only_prerequisites=order_only_prereqs; recipe }

  let generate buf t =
    bprintf buf "%s: %s%s\n"
      (String.concat " " t.targets)
      (String.concat " " t.prerequisites)
      (match t.order_only_prerequisites with
       | []  -> ""
       | l   -> sprintf " | %s" (String.concat " " l));
    let () = match t.recipe with
      | [] -> bprintf buf "\t@\n"
      | l  -> List.iter (bprintf buf "\t%s\n") l
    in
    bprintf buf "\n"

  let target = "$@"
  let target_member = "$%"
  let prereq = "$<"
  let changed_prereqs = "$?"
  let prereqs = "$^"
  let dedup_prereqs = "$+"
  let stem = "$*"

end

type t = {
  header: string list;
  phony: string list;
  variables: Variable.t list;
  rules: Rule.t list;
}

let create ?(header=[]) ?(phony=[]) variables rules =
  { phony; header; variables; rules }

let generate ?(file="Makefile") t =
  let buf = Buffer.create 1024 in
  bprintf buf "# Generated by ocaml-makefile\n\n\n";
  List.iter (fun s ->
      Buffer.add_string buf s;
      Buffer.add_string buf "\n\n";
    ) t.header;
  let () = match t.phony with
    | [] -> ()
    | l  -> bprintf buf ".PHONY: %s\n\n" (String.concat " " l)
  in
  List.iter (Variable.generate buf) t.variables;
  bprintf buf "\n\n";
  List.iter (Rule.generate buf) t.rules;
  let oc = open_out file in
  output_string oc (Buffer.contents buf);
  close_out oc

let (/) x y =
  match x with
  | None   -> y
  | Some x -> Filename.concat x y

module rec Depend: sig
  type t
  val unit: string -> t
  val local: Library.t -> t
  val camlp4o : string -> t
  val library: string -> t
  val ppflags: string -> t list -> Variable.t option
  val compflags: string -> t list -> Variable.t
  val prereqs: ?cmx:bool -> t list -> string list
end = struct

  type local = { name: string; dir: string }

  type t =
    | Unit of string
    | Local of Library.t
    | Camlp4o of string
    | Library of string

  let unit t = Unit t

  let local t = Local t

  let camlp4o t = Camlp4o t

  let library t = Library t

  let ppflags name deps =
    let deps = List.fold_left (fun acc -> function Camlp4o c -> c :: acc | _ -> acc) [] deps in
    match List.rev deps with
    | []   -> None
    | deps ->
      let deps =  String.concat " " deps in
      let cmd  = sprintf "ocamlfind query %s -r -predicates byte,syntax -format \"-I %%d %%a\"" deps in
      Some (Variable.shell ("PPFLAGS_" ^ name) cmd)

  let compflags name deps =
    let incls = List.fold_left (fun acc -> function
        | Local l -> begin
            match Library.dir l with
            | None   -> acc
            | Some d -> ("-I "^ d) :: acc
          end
        | _ -> acc) [] deps in
    let incls = match incls with
      | [] -> ""
      | l  -> String.concat " " (List.rev l) in
    let libs = List.fold_left (fun acc -> function
        | Library c
        | Camlp4o c -> c :: acc
        | _         -> acc
      ) [] deps in
    let libs = match libs with
      | [] -> ""
      | l  ->
        let libs = String.concat " "  (List.rev l) in
        sprintf "$(shell ocamlfind query %s -r -predicates byte -format \"-I %%d\")" libs in
    let flags = sprintf "%s %s" incls libs in
    let var = "COMFLAGS_" ^ name in
    Variable.(var := flags)

  let prereqs ?(cmx=false) deps =
    let units = List.fold_left (fun acc -> function
        | Unit d  -> (d ^ ".cmi") :: acc
        | Local l ->
          let units = Library.units l in
          let cmxs = List.map (fun u -> Unit.dir u / Unit.name u ^ ".cmx") units in
          let cmis = List.map (fun u -> Unit.dir u / Unit.name u ^ ".cmi") units in
          (if cmx then cmxs else []) @ cmis @ acc
        | _       -> acc
      ) [] deps in
    List.rev units

  let files ext deps =
    let units = List.fold_left (fun acc -> function
        | Unit d    -> (d ^ ext) :: acc
        | _         -> acc
      ) [] deps in
    List.rev units

end

and Unit: sig
  type t
  val name: t -> string
  val dir: t -> string option
  val with_dir: t -> string option -> t
  val create: ?dir:string -> ?deps:Depend.t list -> string -> t
  val variables: t -> Variable.t list
  val rules: t -> Rule.t list
  val generated: t -> string list
end = struct

  type t = {
    dir: string option;
    deps: Depend.t list;
    ppflags: Variable.t option;
    compflags: Variable.t;
    name: string;
  }

  let dir t = t.dir

  let name t = t.name

  let with_dir t dir = { t with dir }

  let create ?dir ?(deps=[]) name =
    let ppflags = Depend.ppflags name deps in
    let compflags = Depend.compflags name deps in
    { dir; deps; ppflags; compflags; name }

  let pp = function
    | None   -> ""
    | Some v -> sprintf " -pp 'camlp4o %s' " (Variable.name v)

  let incl = function
    | None   -> ""
    | Some s -> sprintf " -I %s " s

  let cmi t =
    let mli = t.dir / t.name ^ ".mli" in
    let ml  = t.dir / t.name ^ ".ml" in
    let cmi = t.dir / t.name ^ ".cmi" in
    let cmo = t.dir / t.name ^ ".cmo" in
    let targets, prereqs =
      if Sys.file_exists mli then [cmi], [mli]
      else [cmo;cmi], [ml] in
    Rule.create "cmi"
      targets
      (prereqs @ Depend.prereqs t.deps)
      [sprintf "ocamlc -c %s%s%s %s" (incl t.dir) (pp t.ppflags) (Variable.name t.compflags) Rule.prereq]

  let cmo t =
    let mli = t.dir / t.name ^ ".mli" in
    if Sys.file_exists mli then
      [Rule.create "cmo"
         [t.dir / t.name ^ ".cmo"]
         (t.dir / (t.name ^ ".ml") :: t.dir / (t.name ^ ".cmi") :: Depend.prereqs t.deps)
         [sprintf "ocamlc -c %s%s%s %s" (incl t.dir) (pp t.ppflags) (Variable.name t.compflags) Rule.prereq]]
    else
      []

  let cmx t =
    Rule.create "cmx"
      [t.dir / t.name ^ ".cmx"]
      (t.dir / (t.name ^ ".ml") :: t.dir / (t.name ^ ".cmi") :: Depend.prereqs ~cmx:true t.deps)
      [sprintf "ocamlopt -c %s%s%s %s" (incl t.dir) (pp t.ppflags) (Variable.name t.compflags) Rule.prereq]

  let rules t =
    cmi t :: cmx t :: cmo t

  let variables t =
    t.compflags ::
    match t.ppflags with
    | None   -> []
    | Some l -> [l]

  let generated t =
    [ (t.dir / t.name ^ ".cmi");
      (t.dir / t.name ^ ".cmo");
      (t.dir / t.name ^ ".cmx");
      (t.dir / t.name ^ ".o");
      (t.dir / t.name ^ ".cma");
      (t.dir / t.name ^ ".cmxa") ]
end

and Library: sig
  type t
  val name: t -> string
  val dir: t -> string option
  val units: t -> Unit.t list
  val create: ?dir:string -> Unit.t list -> string -> t
  val variables: t -> Variable.t list
  val rules: t -> Rule.t list
  val generated: t -> string list
end = struct

  type t = {
    dir : string option;
    name: string;
    units: Unit.t list;
  }

  let name t = t.name

  let dir t = t.dir

  let units t = t.units

  let create ?dir units name =
    let units = List.map (fun u -> Unit.with_dir u dir) units in
    { dir; name; units }

  let cma t =
    let files = List.map (fun f -> Unit.dir f / Unit.name f ^ ".cmo") t.units in
    Rule.create "cma" [t.dir / t.name ^ ".cma"] files [
      sprintf "ocamlc -a %s -o %s" (String.concat " " files) Rule.target
    ]

  let cmxa t =
    let files = List.map (fun f -> Unit.dir f / Unit.name f ^ ".cmx") t.units in
    Rule.create "cma" [t.dir / t.name ^ ".cmxa"] files [
      sprintf "ocamlopt -a %s -o %s" (String.concat " " files) Rule.target
    ]

  let variables t =
    List.concat (List.map Unit.variables t.units)

  let rules t =
    (Rule.create t.name
       [t.name]
       [t.dir / t.name ^ ".cma"; t.dir / t.name ^ ".cmxa"]
       []
    ) :: cma t :: cmxa t :: List.concat (List.map Unit.rules t.units)

  let generated t =
    [ (t.dir / t.name ^ ".cma");
      (t.dir / t.name ^ ".a");
      (t.dir / t.name ^ ".cmxa");
    ] @ List.concat (List.map Unit.generated t.units)

end

let libraries libs =
  let variables = List.concat (List.map Library.variables libs) in
  let rules = List.concat (List.map Library.rules libs) in
  let main = Rule.create "main" ["all"] (List.map Library.name libs) [] in
  let clean = Rule.create "clean" ["clean"] [] [
      (let dirs = List.map (fun d ->
           match Library.dir d with
           | None   -> ""
           | Some d -> sprintf "%s/*~" d) libs in
       sprintf "rm -f *~ %s" (String.concat " " dirs));
      (let generated = List.concat (List.map Library.generated libs) in
       sprintf "rm -f %s" (String.concat " " generated));
    ] in
  create
    ~phony:["all"; "clean"]
    variables
    (main :: clean :: rules)

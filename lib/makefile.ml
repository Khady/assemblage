(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Project
open Printf

let (/) x y = Filename.concat x y

let (//) x y =
  match x with
  | None   -> y
  | Some x -> Filename.concat x y


module Variable = struct

  type assign = string

  type t = {
    name    : string;
    assign  : assign;
    contents: contents;
  }

  and contents =
    [ `String of string
    | `Strings of string list
    | `Case of (t list * contents) list ]

  let (=:=) name contents =
    { name; contents; assign = ":=" }

  let (=+=) name contents =
    { name; contents; assign = "+=" }

  let (=?=) name contents =
    { name; contents; assign = ":=" }

  let subst t name ~input ~output =
    { name; assign = "=";
      contents = `String (sprintf "$(${%s}:%s=%s)" t.name input output)
    }

  let name t =
    sprintf "$(%s)" t.name

  let generate buf t =
    let string c =
      bprintf buf "%-15s %s %s\n" t.name t.assign c in
    let rec contents = function
      | `String s   -> string s
      | `Strings ss -> string (String.concat " " ss)
      | `Case cases ->
        let rec aux = function
          | []                -> ()
          | (vars, c) :: rest ->
            if vars <> [] then (
              bprintf buf "ifeq (";
              List.iter (fun var -> bprintf buf "$(%s:1=)" var.name) vars;
              bprintf buf ",)\n";
            );
            contents c;
            if vars <> [] && rest <> [] then
              bprintf buf "else\n";
            aux rest;
            if vars <> [] then
              bprintf buf "endif\n" in
        aux cases in
    contents t.contents

  let shell name command =
    { name; assign = "=";
      contents = `String (sprintf "$(shell %s)" command)
    }

  let files name ~dir ~ext =
    { name; assign = "=";
      contents = `String (sprintf "$(wildcard %s/*.%s)" dir ext) }

  let has_feature f =
    let var = String.uppercase (Feature.name f) in
    for i = 0 to String.length var - 1 do
      match var.[i] with
      | '-' -> var.[i] <- '_'
      | _   -> ()
    done;
    ("HAS_" ^ var) =?= `String (if Feature.default f then "1" else "0")

  let has_native =
    has_feature Feature.native

  let has_native_dynlink =
    has_feature Feature.native_dynlink

end

module Rule = struct

  type t = {
    ext: bool;
    targets: string list;
    prerequisites:string list;
    order_only_prerequisites:string list;
    recipe:string list;
  }

  let create ?(ext=false) ~targets ~prereqs ?(order_only_prereqs=[]) recipe =
    { ext; targets;
      prerequisites=prereqs;
      order_only_prerequisites=order_only_prereqs;
      recipe }

  let generate buf t =
    bprintf buf "%s%s %s%s\n"
      (String.concat " " t.targets)
      (if t.ext then "::" else ":")
      (String.concat " " t.prerequisites)
      (match t.order_only_prerequisites with
       | []  -> ""
       | l   -> sprintf " | %s" (String.concat " " l));
    let () = match t.recipe with
      | [] -> bprintf buf "\t@\n"
      | l  -> List.iter (bprintf buf "\t%s\n") l
    in
    bprintf buf "\n"

  let target = "$@"
  let target_member = "$%"
  let prereq = "$<"
  let changed_prereqs = "$?"
  let prereqs = "$^"
  let dedup_prereqs = "$+"
  let stem = "$*"

end


type t = {
  header: string list;
  phony: string list;
  variables: Variable.t list;
  rules: Rule.t list;
}

let create ?(header=[]) ?(phony=[]) variables rules =
  { phony; header; variables; rules }

let write ?(file="Makefile") t =
  printf "\027[36m+ write %s\027[m\n" file;
  let buf = Buffer.create 1024 in
  bprintf buf "# Generated by ocaml-tools\n\n";
  List.iter (fun s ->
      Buffer.add_string buf s;
      Buffer.add_string buf "\n\n";
    ) t.header;
  let () = match t.phony with
    | [] -> ()
    | l  -> bprintf buf ".PHONY: %s\n\n" (String.concat " " l)
  in
  List.iter (Variable.generate buf) t.variables;
  bprintf buf "\n";
  List.iter (Rule.generate buf) t.rules;
  let oc = open_out file in
  output_string oc (Buffer.contents buf);
  close_out oc

(******************************************************************************)

let destdir = "$(DESTDIR)"

module Unit: sig
  include (module type of Unit with type t = Unit.t)
  val rules: t -> Rule.t list
  val variables: t -> Variable.t list
end = struct

  type ext = {
    p4flags  : Variable.t option;
    compflags: Variable.t;
    prereqs  : [`native | `byte] -> string list;
  }

  let p4oflags t =
    match Unit.p4oflags t (Ocamlfind.p4o destdir) with
    | [] -> None
    | l  ->
      let var = "P4FLAGS_" ^ Unit.name t in
      Some (Variable.(var =?= `Strings l))

  let compflags t =
    let links = Unit.compflags t (Ocamlfind.incl destdir) in
    let var = "COMPFLAGS_" ^ Unit.name t in
    Variable.(var =?= `Strings links)

  let prereqs t mode =
    let units = Dep.get_units (Unit.deps t) in
    let units = List.map (fun u ->
        match mode with
        | `native -> destdir / Unit.cmx u
        | `byte   -> destdir / Unit.cmi u
      ) units in
    let libs = Dep.get_libs (Unit.deps t) in
    let libs = List.map (fun l ->
        match mode with
        | `native -> destdir / Lib.cmxa l
        | `byte   -> destdir / Lib.cma l
      ) libs in
    units @ libs

  let process t =
    let prereqs = prereqs t in
    let compflags = compflags t in
    let p4flags = p4oflags t in
    { prereqs; compflags; p4flags }

  let rules t =

    let x = process t in

    let pp = match x.p4flags with
      | None   -> ""
      | Some v -> sprintf "-pp '$(CAMLP4O) %s' " (Variable.name v) in

    let incl = match Unit.build_dir t with
      | None   -> ""
      | Some l -> sprintf "-I %s " ("$(DESTDIR)" / l) in

    let target ext = destdir / Unit.file t ext in
    let source ext = Unit.dir t // Unit.name t ^ ext in

    let ln = (* link source file to target directory *)
      let aux ext =
        let source = source ext in
        let target = target ext in
        if Sys.file_exists source then
          [Rule.create[target] [source] [
              (match Unit.build_dir t with
               | None   -> sprintf "mkdir -p %S" "$(DESTDIR)"
               | Some d -> sprintf "mkdir -p %s" ("$(DESTDIR)" / d));
              sprintf "ln -sf $(shell pwd)/%s %s" source target
            ]]
        else []
      in
      aux ".ml" @ aux ".mli"
    in

    let cmi = (* generate cmis *)
      let targets, prereqs =
        if Sys.file_exists (source ".mli") then [target ".cmi"], [target ".mli"]
        else [target ".cmo"; target ".cmi"], [target ".ml"] in
      [Rule.create targets (prereqs @ x.prereqs `byte) [
          sprintf "$(OCAMLC) -c %s%s%s %s"
            incl pp (Variable.name x.compflags) Rule.prereq
        ]]
    in

    let cmo = (* Generate cmos *)
      if Sys.file_exists (source ".mli") then
        [Rule.create [target ".cmo"] (target ".ml" :: target ".cmi" :: x.prereqs `byte)
           [sprintf "$(OCAMLC) -c %s%s%s %s"
              incl pp (Variable.name x.compflags) Rule.prereq]]
      else
        []
    in

    let cmx = (* Generate cmxs *)
      [Rule.create [target ".cmx"] (target ".ml" :: target ".cmi" :: x.prereqs `native)
         [sprintf "$(OCAMLOPT) -c %s%s%s %s"
            incl pp (Variable.name x.compflags) Rule.prereq]]
    in
    ln @ cmi @ cmo @ cmx

    let variables t =
      let x = process t in
      x.compflags :: match x.p4flags with
      | None   -> []
      | Some l -> [l]

    include Unit

end

let conmap f l = List.concat (List.map f l)

let echo_prereqs =
  sprintf "@echo '\027[36m== Building %s\027[m'" Rule.prereqs

module Lib: sig
  include (module type of Lib with type t = Lib.t)
  val rules: t -> Rule.t list
  val variables: t -> Variable.t list
  val variable: t -> string
end = struct

  let variable t =
    "lib-" ^ Lib.name t

  let variables t =
    let cma  = destdir / Lib.cma t in
    let cmxa = destdir / Lib.cmxa t in
    let cmxs = destdir / Lib.cmxs t in
    let case = [
      [Variable.has_native; Variable.has_native_dynlink], `Strings [cma; cmxa; cmxs];
      [Variable.has_native]                             , `Strings [cma; cmxa];
      []                                                , `Strings [cma];
    ] in
    [Variable.(variable t =?= `Case case)]
    @ conmap Unit.variables (Lib.units t)

  let rules t =
    let byte =
      let cmo = List.map (fun u -> destdir / Unit.cmo u) (Lib.units t) in
      Rule.create [destdir / Lib.cma t] cmo [
        sprintf "$(OCAMLC) -a %s -o %s" Rule.prereqs Rule.target
      ] in
    let native mode =
      let name, file, mode = match mode with
        | `shared  -> "cmxs", destdir / Lib.cmxs t, "-shared"
        | `archive -> "cmxa", destdir / Lib.cmxa t, "-a" in
      let cmx = List.map (fun u -> destdir / Unit.cmx u) (Lib.units t) in
      Rule.create [file] cmx [
        sprintf "$(OCAMLOPT) %s %s -o %s" mode Rule.prereqs Rule.target
      ] in
    Rule.create [variable t] [sprintf "$(%s)" (variable t)] [echo_prereqs]
    :: byte
    :: native `archive
    :: native `shared
    :: conmap Unit.rules (Lib.units t)

  include Lib

end

module Top: sig
  include (module type of Top with type t = Top.t)
  val rules: t -> Rule.t list
  val variables: t -> Variable.t list
  val variable: t -> string
end = struct

  let variable t =
    "top-" ^ Top.name t

  let variables t =
    let link =
      Top.deps t
      |> Dep.closure
      |> Dep.get_pkgs
      |> fun pkgs -> Ocamlfind.bytlink destdir (`Pkgs pkgs)
    in
    let units =
      Top.deps t
      |> Dep.get_units
    in
    let var = sprintf "LINKTOP_%s" (Top.name t)
    in Variable.(var        =?= `String link)
    :: Variable.(variable t =?= `String (destdir / Top.byte t))
    :: conmap Unit.variables units

  let rules t =
    let cma =
      Top.deps t
      |> Dep.closure
      |> Dep.get_libs
      |> List.map (fun l -> destdir / Lib.cma l) in
    let units =
      Top.deps t
      |> Dep.get_units
    in
    let link = sprintf "$(LINKTOP_%s)" (Top.name t) in
    Rule.create [variable t] [sprintf "$(%s)" (variable t)] [echo_prereqs]
    ::
    Rule.create [destdir / Top.byte t] cma [
      sprintf "mkdir -p %s" (destdir / Top.name t);
      sprintf "$(OCAMLMKTOP) %s %s -o %s" link Rule.prereqs Rule.target
    ]
    ::
    conmap Unit.rules units

  include Top

end

module Bin: sig
  include (module type of Bin with type t = Bin.t)
  val rules: t -> Rule.t list
  val variables: t -> Variable.t list
  val variable: t -> string
end = struct

  let variable t =
    "bin-" ^ Bin.name t

  let bytvar t = "BYTLINKFLAGS_" ^ Bin.name t
  let natvar t = "NATLINKFLAGS_" ^ Bin.name t

  let variables t =
    let pkgs =
      Bin.deps t
      |> Dep.closure
      |> Dep.get_pkgs in
    let bytlink = Ocamlfind.bytlink destdir (`Pkgs pkgs) in
    let natlink = Ocamlfind.natlink destdir (`Pkgs pkgs) in
    let units = Bin.deps t |> Dep.get_units
    in Variable.(variable t =?= `Case [
        [Variable.has_native], `Strings [destdir / Bin.byte t; destdir / Bin.native t];
        []                   , `String  (destdir / Bin.byte t);
      ])
    :: Variable.(bytvar t   =?= `String bytlink)
    :: Variable.(natvar t   =?= `String natlink)
    :: conmap Unit.variables units

  let rules t =
    let libs = Bin.deps t |> Dep.closure |> Dep.get_libs in
    let bytlibs = List.map (fun l -> destdir / Lib.cma l) libs in
    let natlibs = List.map (fun l -> destdir / Lib.cmxa l) libs in
    let units = Bin.deps t |> Dep.get_units in
    let bytunits = List.map (fun u -> destdir / Unit.cmo u) units in
    let natunits = List.map (fun u -> destdir / Unit.cmx u) units in
    Rule.create [variable t] [sprintf "$(%s)" (variable t)] [echo_prereqs]
    ::
    Rule.create [destdir / Bin.byte t] (bytlibs @ bytunits) [
      sprintf "mkdir -p %s" (destdir / Bin.name t);
      sprintf "$(OCAMLC) $(%s) %s -o %s" (bytvar t) Rule.prereqs Rule.target;
    ]
    ::
    Rule.create [destdir / Bin.native t] (natlibs @ natunits) [
      sprintf "mkdir -p %s" (destdir / Bin.name t);
      sprintf "$(OCAMLOPT) $(%s) %s -o %s" (natvar t) Rule.prereqs Rule.target;
    ]
    ::
    conmap Lib.rules libs @ conmap Unit.rules units

  include Bin

end

(* dedup while keeping the initial order *)
let dedup l =
  let saw = Hashtbl.create (List.length l) in
  let rec aux acc = function
    | []   -> List.rev acc
    | h::t ->
      if Hashtbl.mem saw h then aux acc t
      else (
        Hashtbl.add saw h true;
        aux (h :: acc) t
      ) in
  aux [] l

let of_project ?(destdir="_build") t =
  let libs = Project.libs t in
  let bins = Project.bins t in
  let tops = Project.tops t in
  let features = List.map Variable.has_feature (Project.features t) in
  let variables =
    dedup (
      Variable.(   "DESTDIR"    =?= `String destdir)
      :: Variable.("OCAMLOPT"   =?= `String "ocamlopt")
      :: Variable.("OCAMLC"     =?= `String "ocamlc")
      :: Variable.("OCAMLMKTOP" =?= `String "ocamlmktop")
      :: Variable.("CAMLP4O"    =?= `String "camlp4o")
      :: features
      @  conmap Lib.variables libs
      @  conmap Bin.variables bins
      @  conmap Top.variables tops
    ) in
  let rules =
    dedup (
      conmap Lib.rules libs @ conmap Bin.rules bins @ conmap Top.rules tops
    ) in
  let main = Rule.create ~ext:true ~targets:["all"] ~prereqs:[] [
      sprintf "@echo '\027[32m== %s\027[m'"
        (String.concat " " (List.map (fun v ->
             sprintf "%s=%s" v.Variable.name (Variable.name v)
           ) features));
      sprintf "@$(MAKE) %s"
        (String.concat " "
           (List.map Lib.variable libs
            @ List.map Bin.variable bins
            @ List.map Top.variable tops));
      sprintf "@echo '\027[32m== Done!\027[m'";
    ] in
  let clean = Rule.create ~ext:true ~targets:["clean"] ~prereqs:[] [
      "rm -f *~ **/*~";
      sprintf "rm -rf $(DESTDIR)";
    ] in
  create
    ~phony:["all"; "clean"]
    variables
    (main :: clean :: rules)

(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

(** EDSL to describe OCaml projects. *)

(** A typical project contains the descriptions of multiple
    components, such as libraries, binaries, tests, ... forming a
    complex DAG of inter-related descriptions. The module signature
    {{!G}G} models the relation between components. *)

type t
(** The type for describing projects. *)

val name: t -> string
(** [name t] is the project name. *)

val version: t -> string
(** [version t] is the project version. *)

val features: t -> Feature.Set.t
(** [features t] is the collection of features used in the project. *)

val files_of_generators: t -> Resolver.t -> string list
(** [files_of_generators t r] is the list of files generated by custom
    generators in the project [t], using the name resolver [r]. *)

val doc_css: t -> string option
(** [doc_css t] is the name of the CSS file for the project
    documentation. *)

val doc_intro: t -> string option
(** [doc_intro t] is the name of the intro file for the project
    documentation. *)

val doc_dir: t -> string
(** [doc_dir t] is the the directory where the HTML documentation is
    generated. *)

module type G = sig

  (** Signature for graphs of components. *)

  include Graph.Sig.I

  val iter: (V.t -> unit) -> t -> unit
  (** Topoligical iteration. *)

  val fold: (V.t -> 'a -> 'a) -> t -> 'a -> 'a
  (** Topological fold. *)

  val vertex: t -> V.t list
  (** [vertex g] is the list of topologically sorted vertices. *)

end

(** Although each kind of components has some particularities, but they all
    extend the signature {{!S}S} defined below. *)

module type S = sig

  (** Common signature shared by all components. *)

  type t
  (** The type for describing a specific kind of project components. *)

  type component
  (** The type for describing generic components. *)

  val id: t -> string
  (** [id t] is the unique name of the component [t]. *)

  val name: t -> string
  (** [name x] is the name that the user gave to the component
      [t]. Component of different kinds can have the same name (for
      instance a library and a binary), use [id] to get a unique
      name. *)

  val deps: t -> component list
  (** [deps t] is the list of dependencies of the component [t]. *)

  val build_dir: t -> Resolver.t -> string
  (** [build_dir t] is the directory where build artifacts of the
      description [t] are built. *)

  val file: t -> Resolver.t -> string -> string
  (** [file t r ext] is the location of the generated file with the
       extension [ext] for the component [t] and the name resolver
       [r]. *)

  val generated_files: t -> Resolver.t -> (Feature.formula * string list) list
  (** [generated_files t r] is the list of generated files and the
      feature which enable them, for the component [t] and the name
      resolver [r]. *)

  val flags: t -> Resolver.t -> Flags.t
  (** [flags t r] are the compilation flags used when generating the
      build artifacts for the project [t] and the name resolver
      [r].  *)

  val prereqs: t -> Resolver.t -> [`Byte | `Native] -> string list
  (** [prereqs t resolver mode] is the list of prerequisites files to
      build, in the given [mode], before building the object [t],
      where [resolver] is used to compute the location of generated
      files. *)

  module Graph: G with type V.t = t
  (** Graph of descriptions. *)

end

module rec Component: sig

  (** Component descriptions. *)

  type t =
    [ `CU of CU.t
    | `Lib of Lib.t
    | `Pp of Lib.t
    | `Pkg_pp of Pkg.t
    | `Pkg of Pkg.t
    | `Bin of Bin.t
    | `C of C.t
    | `JS of JS.t
    | `Test of Test.t
    | `Gen of Gen.t ]
  (** The type for describing project components. *)

  include S with type t := t and type component = t

  val cu: t -> CU.t option
  (** Is the component a compilation unit? *)

  val lib: t -> Lib.t option
  (** Is the component a local library? *)

  val pkg: t -> string option
  (** Is the component a globally installed library in a package? *)

  val pp: t -> Lib.t option
  (** Is the component a local syntax extension? *)

  val pkg_pp: t -> string option
  (** Is the component a globally installed syntax extension *)

  val bin: t -> Bin.t option
  (** Is the component a binary? *)

  val c: t -> C.t option
  (** Is the component a C file? *)

  val js: t -> JS.t option
  (** Is the component a js_of_ocaml binary? *)

  val gen: t -> Gen.t option
  (** Is the component a generated source file? *)

  val test: t -> Test.t option
  (** Is the component a test? *)

  val filter: (t -> 'a option) -> t list -> 'a list
  (** Filter a list of components. *)

  val closure: t list -> t list
  (** Compute the transitive closure of the component dependency
      graph. Try to keep the order as consistent as possible. *)

end

and CU: sig

  (** Signature for compilation units. *)

  include S with type component = Component.t

  val create:
    ?flags:Flags.t ->
    ?dir:string ->
    ?deps:Component.t list -> string -> t
  (** Create a compilation unit. *)

  val copy: t -> t
  (** Copy the compilation unit. *)

  val dir: t -> string option
  (** The source directory of the compilation unit. *)

  val container: t -> [`Lib of Lib.t |`Bin of Bin.t]  option
  (** The library the compilation unit belongs to. *)

  val mli: t -> bool
  (** Has the compilation unit an [mli] file. *)

  val ml: t -> bool
  (** Has the compilation unit an [ml] file. *)

  val for_pack: t -> string option
  (** The (optional) pack the compilation unit is in. *)

  val generated: t -> bool
  (** [generator t] is either [None], which means that the source file
      is not generated, or [Some files] when the source files [files]
      of the compilation unit are generated. *)

  val pack: ?flags:Flags.t -> t list -> string -> t
  (** Pack a collection of compilation units together. *)

  val unpack: t -> t list
  (** The (usually empty) list of packed compilation units. *)

  val cmi: t -> Resolver.t -> string
  (** The location of the generated compiled module interface. *)

  val cmo: t -> Resolver.t -> string
  (** The location of the generated compiled module object. *)

  val cmx: t -> Resolver.t -> string
  (** The location of the extra information for native linking of the
      compilation unit. *)

  val o: t -> Resolver.t -> string
  (** The location of the object file for the compilation unit. *)

end

and Lib: sig

  (** Library descriptions. *)

  include S with type component = Component.t

  val create:
    ?available:Feature.formula ->
    ?flags:Flags.t ->
    ?pack:bool ->
    ?deps:Component.t list -> CU.t list -> string -> t
  (** Create a library. *)

  val filename: t -> string
  (** The library filename. Usually, it is the same as [name], but
      this could be updated when the library is put in a named project
      to [project.name]. *)

  val compilation_units: t -> CU.t list
  (** The list of compilation units which defines the library. *)

  val available: t -> Feature.formula
  (** The features which enables the build of that library. *)

  val cma: t -> Resolver.t -> string
  (** The location of the generated bytecode archive. *)

  val cmxa: t -> Resolver.t -> string
  (** The location of the extra information about the native
      archive. *)

  val a: t -> Resolver.t -> string
  (** The location of the native archive. *)

  val cmxs: t -> Resolver.t -> string
  (** The location of the shared archive. *)

end

and Bin: sig

  (** Binary descriptions. *)

  include S with type component = Component.t

  val create:
    ?available:Feature.formula ->
    ?byte_only:bool ->
    ?link_all:bool ->
    ?install:bool ->
    ?flags:Flags.t ->
    ?deps:Component.t list ->
    CU.t list -> string -> t
  (** Build a binary by linking a set of compilation units. *)

  val toplevel:
    ?available:Feature.formula ->
    ?flags:Flags.t ->
    ?custom:bool ->
    ?install:bool ->
    ?deps:Component.t list ->
    CU.t list -> string -> t
  (** Create a custom toplevel by linking a set of compilation
      units. *)

  val compilation_units: t -> CU.t list
  (** The list of compilation units contained in the binary. *)

  val available: t -> Feature.formula
  (** The features which enables the build of that library. *)

  val is_toplevel: t -> bool
  (** Is the binary a toplevel. *)

  val install: t -> bool
  (** Should the binary be installed. *)

  val byte: t -> Resolver.t -> string
  (** The location of the generated byte-code binary. *)

  val native: t -> Resolver.t -> string
  (** The location of the generated native binary. *)

end

and Pkg: sig

  (** External package (globally installed using [ocamlfind]. *)

  include S with type t = string and type component = Component.t

end

and Gen: sig

  (** Source file generator. *)

  include S with type component = Component.t

  val create: ?deps:Component.t list -> ?action:(Resolver.t -> Action.t) ->
    [`Both|`ML|`MLI]-> string -> t
  (** Generate source files, using the given action. *)

  val copy: t -> t
  (** Copy the generator if it needs to run in an other directory. *)

end

and JS: sig

  (** Compilation to JavaScript. *)

  include S with type component = Component.t

  val create: Bin.t -> string list -> t
  (** Create a {i .js} object, using [js_of_ocaml]. *)

  val js: t -> Resolver.t -> string
  (** The location of the generated javascript artifacts. *)

end

and C: sig

  (** C files. *)

  include S with type component = Component.t

  val create:
    ?dir:string -> ?generated:bool -> ?link_flags:string list ->
    ?deps:Component.t list -> string -> t
  (** Create a C object file. *)

  val dll_so: t -> Resolver.t -> string
  (** The location of the generated [.so] file. *)

end

and Test: sig

  (** Test-cases *)

  include S with type component = Component.t
  (** Test values. *)

  type command =
    [ `Bin of Bin.t * string list
    | `Shell of string ]

  val create: ?dir:string -> ?deps:Component.t list -> command list -> string -> t
  (** Create a test. *)

  val dir: t -> string option
  (** The directory where to run the test. *)

  val commands: t -> command list
  (** The list of commands to run the test. *)

end

val create:
  ?flags:Flags.t ->
  ?doc_css:string -> ?doc_intro:string -> ?doc_dir:string ->
  ?version:string ->
  Component.t list -> string -> t
(** [create cs n] is the project named [n] with components [cs]. *)

val components: t -> Component.t list
(** Return the project components. *)

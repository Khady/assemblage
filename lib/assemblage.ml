(*
 * Copyright (c) 2014 Thomas Gazagnaire <thomas@gazagnaire.org>
 *
 * Permission to use, copy, modify, and distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR
 * ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
 * ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF
 * OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
 *)

open Printf
open Project

module Bag = struct

  let comp_tbl = Hashtbl.create 8

  let default = "main"

  let find bag =
    try Hashtbl.find comp_tbl bag
    with Not_found ->
      let g = CU.Graph.create () in
      Hashtbl.add comp_tbl bag g;
      g

  let add bag u deps =
    let g = find bag in
    CU.Graph.add_vertex g u;
    Component.(filter cu) deps
    |> List.iter (fun u' -> CU.Graph.add_edge g u' u)

end

let projects_list = ref []

let projects () =
  !project_list

let comp ?(bag=Bag.default) ?(dir="lib") deps name =
  let u = CU.create ~dir ~deps name in
  Bag.add bag u deps;
  `CU u

let generated ?deps ?action f name =
  let g = Gen.create ?deps ?action f name in
  `Gen g

let lib ?(bag=Bag.default) name =
  let g = Bag.find bag in
  let l = Lib.create (CU.Graph.vertex g) name in
  `Lib l

let bin ?byte_only ?link_all ?install ?(dir="bin") deps comps name =
  let comps = List.map (CU.create ~dir ~deps) comps in
  let b = Bin.create ?byte_only ?link_all ?install comps name in
  `Bin b

let c ?(dir="stubs") ?(link_flags=[]) libs name =
  let link_flags = List.map (sprintf "-l%s") libs @ link_flags in
  let c = C.create ~dir ~link_flags name in
  `C c

let js t r = `JS (JS.create t r)

let pkg x = `Pkg x

let pkg_pp x = `Pkg_pp x

(* Ctypes stub-generation *)

let cstubs ?bag ?dir ?(headers=[]) ?(cflags=[]) ?(clibs=[]) deps name =

  (* 1. compile the bindings. *)
  let deps = `Pkg "ctypes.stubs" :: deps in
  let name_bindings = name ^ "_bindings" in
  let bindings = comp ?bag ?dir deps name_bindings in

  (* 2. Generate and compile the generator. *)
  let name_generator = name ^ "_generator" in
  let generator =
    let action r =
      let headers = match headers with
        | [] -> ""
        | hs -> sprintf "--headers %s " (String.concat "," hs) in
      Action.create ~dir:(Resolver.build_dir r "") "ctypes-gen %s" headers
    in
    let gen = generated ~action `ML name_generator in
    let comp = CU.create ~deps:[gen; bindings] name_generator in
    let bin =
      Bin.create ~install:false [comp] name_generator in
    `Bin bin in

  (* 3. Generate and compile the stubs. *)
  let name_stubs = name ^ "_stubs" in
  let ml_stubs =
    let action r =
      Action.create ~dir:(Resolver.build_dir r "") "./%s.byte" name_generator in
    let gen = generated ~deps:[generator] ~action `ML name_stubs in
    comp ?bag [gen] name_stubs in
  let link_flags = cflags @ List.map (sprintf "-l%s") clibs in
  let c_stubs =
    let c = C.create ~generated:true ~deps:[generator] ~link_flags name_stubs in
    `C c in
  let flags = Flags.(cclib link_flags @ stub name_stubs) in
  let gen = generated ~deps:[generator] `ML name in
  let comp = comp ?bag [bindings; ml_stubs; c_stubs; gen] name in
  let comp = match Component.cu comp with
    | Some c -> c
    | None   -> assert false in
  let lib = Lib.create ~flags [comp] name in
  `Lib lib

let timestamp =
  let t = Unix.gettimeofday () in
  let months = [| "Jan"; "Feb"; "Mar"; "Apr"; "May"; "Jun";
                  "Jul"; "Aug"; "Sep"; "Oct"; "Nov"; "Dec" |] in
  let days = [| "Sun"; "Mon"; "Tue"; "Wed"; "Thu"; "Fri"; "Sat" |] in
  let time = Unix.gmtime t in
  let date =
    Printf.sprintf "%s, %d %s %d %02d:%02d:%02d GMT"
      days.(time.Unix.tm_wday) time.Unix.tm_mday
      months.(time.Unix.tm_mon) (time.Unix.tm_year+1900)
      time.Unix.tm_hour time.Unix.tm_min time.Unix.tm_sec in
  Printf.sprintf "Generated by Assemblage (%s)." date

type tool = t -> Build_env.t -> unit

let sys_argl = Array.to_list Sys.argv

let auto_load () =
  List.for_all ((<>) "--disable-auto-load") sys_argl

let includes () =
  let rec aux acc = function
    | []             -> List.rev acc
    | "-I" :: h :: t -> aux (h::acc) t
    | _ :: t         -> aux acc t in
  aux [] sys_argl

let process ?(file="configure.ml") name fn =
  let includes = includes () in
  let auto_load = auto_load () in
  Shell.show "Loading %s. %s"
    (Shell.color `bold file)
    (if auto_load then "" else
       sprintf "[auto-load: %s]"
         (Shell.color `magenta (string_of_bool auto_load)));
  Toploop.initialize_toplevel_env ();
  Toploop.set_paths ();
  let includes =
    if auto_load then
      includes @ Shell.exec_output "ocamlfind query -r assemblage"
    else
      includes in
  List.iter Topdirs.dir_directory includes;
  if not (Sys.file_exists file) then
    Shell.fatal_error 1 "missing %s." file
  else match Toploop.use_silently Format.std_formatter file with
    | false -> Shell.fatal_error 1 "while loading `%s'." file
    | true  ->
      match Project.list () with
      | [] -> Shell.fatal_error 2 "No projects are registered in `%s'." file
      | ts ->
        let features = List.fold_left (fun acc t ->
            Feature.Set.union (Project.features t) acc
          ) Feature.Set.empty ts in
        let env = Build_env.parse name features in
        List.iter (fun t -> fn t env) ts

let configure `Make t env =
  let features = Build_env.features env in
  let flags = Build_env.flags env in
  let makefile = "Makefile" in
  let build_dir = Build_env.build_dir env in
  Makefile.(write @@ of_project t ~features ~flags ~makefile);
  Ocamlfind.META.(write @@ of_project t);
  Opam.Install.(write @@ of_project ~build_dir t)

let describe t env =
  let print_deps x = match Dep.(filter pkg x) @ Dep.(filter pkg_pp x) with
    | [] -> ""
    | ds -> sprintf "  ├─── [%s]\n"
              (String.concat " " (List.map (Shell.color `bold) ds)) in
  let print_modules last ms =
    let aux i n m =
      printf "  %s %s\n"
        (if last && i = n then "└───" else "├───") (Shell.color `blue m) in
    let n = List.length ms - 1 in
    List.iteri (fun i m -> aux i n m) ms in
  let print_units us =
    let aux i n u =
    let mk f ext =
      if f u then (Shell.color `cyan @@ Comp.name u ^ ext) else "" in
    let ml = mk Comp.ml ".ml" in
    let mli = mk Comp.mli ".mli" in
    printf "  %s %-25s%-25s\n" (if i = n then "└─" else "├─") ml mli;
    let build_dir = Build_env.build_dir env in
    print_modules (i=n) (OCaml.modules ~build_dir u)
    in
    let n = List.length us - 1 in
    List.iteri (fun i u -> aux i n u) us in
  let print_top id deps comps ls =
    let aux l =
      printf "└─┬─ %s\n%s"
        (Shell.color `magenta (id l)) (print_deps @@ deps l);
      print_units (comps l) in
    List.iter aux ls in
  let print_libs = print_top Lib.id Lib.deps Lib.comps in
  let print_bins = print_top Bin.id Bin.deps Bin.comps in
  printf "\n%s %s %s\n\n"
    (Shell.color `yellow "==>")
    (Shell.color `underline (Project.name t)) (Project.version t);
  let contents = Project.contents t in
  print_libs Dep.(filter lib contents);
  print_libs Dep.(filter pp contents);
  print_bins Dep.(filter bin contents)
